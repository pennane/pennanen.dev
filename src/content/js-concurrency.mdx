---
title: 'Handling promises first come first serve'
date: '23.02.2025'
draft: 'true'
---

# HMMM

```ts
export async function* racePromises<A, B>(f: (x: A) => Promise<B>, xs: A[]) {
  const size = xs.length
  const pool = new Map<number, Promise<readonly [number, B]>>()

  for (const [i, x] of xs.entries()) {
    pool.set(
      i,
      f(xs[i]).then((v) => [i, v] as const)
    )
  }

  while (pool.size) {
    const [key, value] = await Promise.race(pool.values())
    pool.delete(key)
    yield value
  }
}
```

```ts
export async function* racePromisesWithMaxConcurrency<A, B>(
  concurrency: number,
  f: (x: A) => Promise<B>,
  xs: A[]
) {
  if (concurrency < 1) {
    throw new Error('Concurrency limit cannot be less than 1')
  }

  const size = xs.length
  const pool = new Map<number, Promise<readonly [number, B]>>()

  let startedPromises = 0

  function queueNext() {
    const i = startedPromises++
    pool.set(
      i,
      f(xs[i]).then((v) => [i, v] as const)
    )
  }

  Array.from({ length: Math.min(concurrency, size) }).forEach(queueNext)

  while (pool.size) {
    const [key, value] = await Promise.race(pool.values())
    pool.delete(key)
    yield value

    if (startedPromises >= size) continue

    queueNext()
  }
}
```
